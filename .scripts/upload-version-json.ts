import * as path from "node:path";
import * as fs from "node:fs";
import { readFileSync, writeFileSync } from "node:fs";
import { basename, extname, resolve } from "node:path";

import { getOctokit } from "@actions/github";
import { getOctokitOptions } from "@actions/github/lib/utils";

// import { uploadAssets } from "./upload-release-assets";
import { getAssetName } from "./utils";

import type { Artifact, TargetInfo } from "./types";
import { config } from "dotenv";

config({ path: ".scripts/.env" });

const env = await import("./env").then((mod) => mod.env);

type Platform = {
  signature: string;
  url: string;
};

type VersionContent = {
  version: string;
  notes: string;
  pub_date: string;
  platforms: {
    [key: string]: Platform;
  };
};

export async function uploadVersionJSON({
  owner,
  repo,
  version,
  notes,
  tagName,
  releaseId,
  artifacts,
  targetInfo,
  unzippedSig,
  updaterJsonPreferNsis,
  updaterJsonKeepUniversal,
}: {
  owner: string;
  repo: string;
  version: string;
  notes: string;
  tagName: string;
  releaseId: string;
  artifacts: Artifact[];
  targetInfo: TargetInfo;
  unzippedSig: boolean;
  updaterJsonPreferNsis: boolean;
  updaterJsonKeepUniversal: boolean;
}) {
  console.log("Uploading version JSON...");
  if (env.GITHUB_TOKEN === undefined) {
    throw new Error("GITHUB_TOKEN is required");
  }

  const github = getOctokit(env.GITHUB_TOKEN);

  const versionFilename = "latest.json";
  const versionFile = resolve(process.cwd(), versionFilename);
  const versionContent: VersionContent = {
    version,
    notes,
    pub_date: new Date().toISOString(),
    platforms: {},
  };

  // const assets``:  = await github.rest.repos.listReleaseAssets({
  //   owner: owner,
  //   repo: repo,
  //   release_id: releaseId,
  //   per_page: 50,
  // });
  const outputDir = path.join(__dirname, "../release");
  // // console.log("outputDir", outputDir);
  const fileNames = fs.readdirSync(outputDir).sort();
  // files.map((f) => ({ name: f, path: path.join(outputDir, f) }));
  console.log("files", fileNames);
  // const assetData = asset.map((file) => {
  //   const filePath = path.join(outputDir, file);
  //   const data = fs.readFileSync(filePath, "utf8");
  //   return data;
  // });
  type Assets = Awaited<ReturnType<typeof github.rest.repos.listReleaseAssets>>;
  const assets: Assets = {
    data: fileNames.map((name) => ({
      url: path.join(outputDir, name),
      browser_download_url: `https://my-tauri-updater.s3.us-west-1.amazonaws.com/app/${version}/${name}`,
      id: 0,
      node_id: "",
      name,
      label: name,
      state: "uploaded",
      content_type: "",
      size: fs.statSync(path.join(outputDir, name)).size,
      download_count: 0,
      created_at: fs
        .statSync(path.join(outputDir, name))
        .birthtime.toISOString(),
      updated_at: fs.statSync(path.join(outputDir, name)).mtime.toISOString(),
      uploader: null,
    })),
    headers: {},
    status: 200,
    url: "",
  };
  // console.log("assets", assets);
  // console.log("asset", asset);

  // console.log("asssetData", assetData);

  const asset = assets.data.find((e) => e.name === versionFilename);

  // console.log("asset", asset);

  if (asset) {
    // const assetData = (
    //   await github.request(
    //     "GET /repos/{owner}/{repo}/releases/assets/{asset_id}",
    //     {
    //       owner: owner,
    //       repo: repo,
    //       asset_id: asset.id,
    //       headers: {
    //         accept: "application/octet-stream",
    //       },
    //     }
    //   )
    const assetData = fs.readFileSync(asset.url, "utf8");
    // ).data as unknown as ArrayBuffer;

    // // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
    versionContent.platforms = JSON.parse(
      Buffer.from(assetData).toString()
      // //   // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
    ).platforms;
  }

  console.log("versionContent", versionContent);

  const downloadUrls = new Map<string, string>();
  // for (const data of assets.data) {
  //   downloadUrls.set(data.name, data.browser_download_url);
  // }

  // type UpdaterJsonAsset = {
  //   downloadUrl: string;
  //   assetName: string;
  //   path: Artifact["path"];
  //   arch: Artifact["arch"];
  // };

  // // Assets matching artifacts generated by this action
  // const filteredAssets: UpdaterJsonAsset[] = [];
  // for (const artifact of artifacts) {
  //   const assetName = getAssetName(artifact.path)
  //     .trim()
  //     .replace(/[ ()[\]{}]/g, ".")
  //     .replace(/\.\./g, ".")
  //     .normalize("NFD")
  //     .replace(/[\u0300-\u036f]/g, "");
  //   const downloadUrl = downloadUrls.get(assetName);
  //   if (downloadUrl) {
  //     filteredAssets.push({
  //       downloadUrl,
  //       assetName,
  //       path: artifact.path,
  //       arch: artifact.arch,
  //     });
  //   }
  // }

  // const signatureFiles = filteredAssets.filter((asset) => {
  //   return asset.assetName.endsWith(".sig");
  // });
  // function signaturePriority(signaturePath: string) {
  //   const priorities = updaterJsonPreferNsis
  //     ? unzippedSig
  //       ? [".exe.sig", ".msi.sig"]
  //       : [".nsis.zip.sig", ".msi.zip.sig"]
  //     : unzippedSig
  //     ? [".msi.sig", ".exe.sig"]
  //     : [".msi.zip.sig", ".nsis.zip.sig"];
  //   for (const [index, extension] of priorities.entries()) {
  //     if (signaturePath.endsWith(extension)) {
  //       return 100 - index;
  //     }
  //   }
  //   return 0;
  // }
  // signatureFiles.sort((a, b) => {
  //   return signaturePriority(b.path) - signaturePriority(a.path);
  // });
  // const signatureFile = signatureFiles[0];
  // if (!signatureFile) {
  //   console.warn(
  //     "Signature not found for the updater JSON. Skipping upload..."
  //   );
  //   return;
  // }

  // const updaterName = basename(
  //   signatureFile.assetName,
  //   extname(signatureFile.assetName)
  // );
  // let downloadUrl = filteredAssets.find(
  //   (asset) => asset.assetName == updaterName
  // )?.downloadUrl;
  // if (!downloadUrl) {
  //   console.warn("Asset not found for the updater JSON. Skipping upload...");
  //   return;
  // }
  // // Untagged release downloads won't work after the release was published
  // downloadUrl = downloadUrl.replace(
  //   /\/download\/(untagged-[^/]+)\//,
  //   tagName ? `/download/${tagName}/` : "/latest/download/"
  // );

  // let os = targetInfo.platform as string;
  // if (os === "macos") {
  //   os = "darwin";
  // }

  // let arch = signatureFile.arch;
  // arch =
  //   arch === "amd64" || arch === "x86_64" || arch === "x64"
  //     ? "x86_64"
  //     : arch === "x86" || arch === "i386"
  //     ? "i686"
  //     : arch === "arm"
  //     ? "armv7"
  //     : arch === "arm64"
  //     ? "aarch64"
  //     : arch;

  // // Expected targets: https://github.com/tauri-apps/tauri/blob/fd125f76d768099dc3d4b2d4114349ffc31ffac9/core/tauri/src/updater/core.rs#L856
  // if (os === "darwin" && arch === "universal") {
  //   // Don't overwrite native builds
  //   if (!versionContent.platforms["darwin-aarch64"]) {
  //     (versionContent.platforms["darwin-aarch64"] as unknown) = {
  //       signature: readFileSync(signatureFile.path).toString(),
  //       url: downloadUrl,
  //     };
  //   }
  //   if (!versionContent.platforms["darwin-x86_64"]) {
  //     (versionContent.platforms["darwin-x86_64"] as unknown) = {
  //       signature: readFileSync(signatureFile.path).toString(),
  //       url: downloadUrl,
  //     };
  //   }
  // }
  // if (updaterJsonKeepUniversal || os !== "darwin" || arch !== "universal") {
  //   (versionContent.platforms[`${os}-${arch}`] as unknown) = {
  //     signature: readFileSync(signatureFile.path).toString(),
  //     url: downloadUrl,
  //   };
  // }

  // writeFileSync(versionFile, JSON.stringify(versionContent, null, 2));

  // if (asset) {
  //   // https://docs.github.com/en/rest/releases/assets#update-a-release-asset
  //   await github.rest.repos.deleteReleaseAsset({
  //     owner: owner,
  //     repo: repo,
  //     release_id: releaseId,
  //     asset_id: asset.id,
  //   });
  // }

  // await uploadAssets(owner, repo, releaseId, [{ path: versionFile, arch: "" }]);
}
